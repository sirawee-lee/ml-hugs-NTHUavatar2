#!/usr/bin/env python3
"""
Convert motion-diffusion-model SMPL parameters to HUGS format.

This script converts the SMPL parameters generated by motion-diffusion-model
(MDM) to the format expected by HUGS for animation.

Usage:
    python scripts/convert_mdm_to_hugs.py \
        --input /path/to/mdm/sample00_rep00_smpl_params.npy \
        --output /path/to/hugs/jumping_motion.npz \
        --betas /path/to/hugs/betas.npy
"""

import argparse
import numpy as np
from pathlib import Path


def _normalize(v, eps=1e-8):
    norm = np.linalg.norm(v, axis=-1, keepdims=True)
    return v / np.clip(norm, eps, None)


def rot6d_to_rotmat(d6):
    """
    Convert 6D rotation representation to rotation matrices.
    d6: (..., 6)
    returns: (..., 3, 3)
    """
    a1 = d6[..., :3]
    a2 = d6[..., 3:]
    b1 = _normalize(a1)
    b2 = a2 - np.sum(b1 * a2, axis=-1, keepdims=True) * b1
    b2 = _normalize(b2)
    b3 = np.cross(b1, b2)
    # Stack as rows (consistent with MDM rotation_6d_to_matrix)
    return np.stack([b1, b2, b3], axis=-2)


def rotmat_to_axis_angle(rotmat, eps=1e-8):
    """
    Convert rotation matrices to axis-angle.
    rotmat: (..., 3, 3)
    returns: (..., 3)
    """
    trace = np.trace(rotmat, axis1=-2, axis2=-1)
    cos_angle = (trace - 1.0) / 2.0
    cos_angle = np.clip(cos_angle, -1.0, 1.0)
    angle = np.arccos(cos_angle)

    rx = rotmat[..., 2, 1] - rotmat[..., 1, 2]
    ry = rotmat[..., 0, 2] - rotmat[..., 2, 0]
    rz = rotmat[..., 1, 0] - rotmat[..., 0, 1]
    axis = np.stack([rx, ry, rz], axis=-1)

    sin_angle = np.sin(angle)
    small = np.abs(sin_angle) < eps
    axis = axis / np.expand_dims(2.0 * np.where(small, 1.0, sin_angle), axis=-1)
    axis = np.where(np.expand_dims(small, axis=-1), 0.0, axis)

    return axis * np.expand_dims(angle, axis=-1)


def euler_xyz_to_rotmat(rx, ry, rz):
    """Build rotation matrix from XYZ Euler angles (radians)."""
    cx, sx = np.cos(rx), np.sin(rx)
    cy, sy = np.cos(ry), np.sin(ry)
    cz, sz = np.cos(rz), np.sin(rz)

    Rx = np.array([[1, 0, 0], [0, cx, -sx], [0, sx, cx]], dtype=np.float32)
    Ry = np.array([[cy, 0, sy], [0, 1, 0], [-sy, 0, cy]], dtype=np.float32)
    Rz = np.array([[cz, -sz, 0], [sz, cz, 0], [0, 0, 1]], dtype=np.float32)
    return Rz @ Ry @ Rx


def convert_mdm_to_hugs(
    mdm_path,
    output_path,
    betas_path=None,
    target_betas=None,
    rotate_x_deg=0.0,
    rotate_y_deg=0.0,
    rotate_z_deg=0.0,
):
    """
    Convert MDM SMPL parameters to HUGS format.
    
    Args:
        mdm_path: Path to MDM SMPL parameters (.npy file)
        output_path: Path to save HUGS format (.npz file)
        betas_path: Optional path to betas .npy file to use
        target_betas: Optional numpy array of betas to use (shape: [10])
    """
    # Load MDM data
    print(f"Loading MDM data from: {mdm_path}")
    mdm_data = np.load(mdm_path, allow_pickle=True).item()
    
    # MDM format:
    # - thetas: (24, 6, num_frames) - joint rotations in rot6d
    # - root_translation: (3, num_frames) - root translation
    
    thetas = mdm_data['thetas']  # (24, 6, num_frames)
    root_trans = mdm_data['root_translation']  # (3, num_frames)
    
    # Transpose to (num_frames, 24, 6) then convert rot6d -> axis-angle
    num_frames = thetas.shape[2]
    thetas_transposed = np.transpose(thetas, (2, 0, 1))  # (num_frames, 24, 6)
    rotmats = rot6d_to_rotmat(thetas_transposed)  # (num_frames, 24, 3, 3)

    # Optional coordinate frame rotation (apply to all rotations + translations)
    if rotate_x_deg != 0.0 or rotate_y_deg != 0.0 or rotate_z_deg != 0.0:
        rx = np.deg2rad(rotate_x_deg)
        ry = np.deg2rad(rotate_y_deg)
        rz = np.deg2rad(rotate_z_deg)
        R_fix = euler_xyz_to_rotmat(rx, ry, rz)
        R_fix_T = R_fix.T
        rotmats = R_fix @ rotmats @ R_fix_T

    poses_aa = rotmat_to_axis_angle(rotmats)  # (num_frames, 24, 3)
    poses_full = poses_aa.reshape(num_frames, -1)  # (num_frames, 72)

    # Split into global_orient and body_pose
    global_orient = poses_full[:, :3]  # (num_frames, 3)
    body_pose = poses_full[:, 3:]  # (num_frames, 69)
    
    # Transpose root translation to (num_frames, 3)
    transl = np.transpose(root_trans, (1, 0))  # (num_frames, 3)
    if rotate_x_deg != 0.0 or rotate_y_deg != 0.0 or rotate_z_deg != 0.0:
        transl = (R_fix @ transl.T).T
    
    # Get or create betas
    if target_betas is not None:
        betas = target_betas
    elif betas_path is not None:
        print(f"Loading betas from: {betas_path}")
        loaded_data = np.load(betas_path)
        # Handle both .npy and .npz files
        if isinstance(loaded_data, np.lib.npyio.NpzFile):
            if 'betas' in loaded_data:
                betas = loaded_data['betas']
            else:
                raise ValueError(f"'betas' key not found in {betas_path}")
        else:
            betas = loaded_data
        
        if betas.ndim == 2:
            betas = betas[0]  # Take first if multiple
        betas = betas[:10]  # Ensure we only have 10 betas
    else:
        # Use default neutral betas
        print("Using default neutral betas (zeros)")
        betas = np.zeros(10, dtype=np.float32)
    
    # Ensure betas has correct shape
    if betas.shape != (10,):
        betas = betas.reshape(10)
    
    print(f"\nConverted data shapes:")
    print(f"  global_orient: {global_orient.shape}")
    print(f"  body_pose: {body_pose.shape}")
    print(f"  transl: {transl.shape}")
    print(f"  betas: {betas.shape}")
    print(f"  num_frames: {num_frames}")
    
    # Save in HUGS format
    output_data = {
        'global_orient': global_orient.astype(np.float32),
        'body_pose': body_pose.astype(np.float32),
        'transl': transl.astype(np.float32),
        'betas': betas.astype(np.float32),
    }
    
    print(f"\nSaving HUGS format to: {output_path}")
    np.savez(output_path, **output_data)
    print("Conversion complete!")
    
    return output_data


def main():
    parser = argparse.ArgumentParser(description='Convert MDM SMPL parameters to HUGS format')
    parser.add_argument('--input', '-i', required=True, 
                        help='Path to MDM SMPL parameters (.npy file)')
    parser.add_argument('--output', '-o', required=True,
                        help='Path to save HUGS format (.npz file)')
    parser.add_argument('--betas', '-b', default=None,
                        help='Optional path to betas .npy file')
    
    parser.add_argument('--rotate_x', type=float, default=0.0,
                        help='Rotate coordinate frame around X (degrees).')
    parser.add_argument('--rotate_y', type=float, default=0.0,
                        help='Rotate coordinate frame around Y (degrees).')
    parser.add_argument('--rotate_z', type=float, default=0.0,
                        help='Rotate coordinate frame around Z (degrees).')

    args = parser.parse_args()
    
    # Create output directory if it doesn't exist
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Convert
    convert_mdm_to_hugs(
        mdm_path=args.input,
        output_path=args.output,
        betas_path=args.betas,
        rotate_x_deg=args.rotate_x,
        rotate_y_deg=args.rotate_y,
        rotate_z_deg=args.rotate_z,
    )


if __name__ == '__main__':
    main()
